<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            background-color: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        #gameCanvas:active {
            cursor: grabbing;
        }

        #instructions {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1;
            text-align: center;
            font-size: 0.8em;
            max-width: 80%;
        }

        #fuelDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1;
            font-size: 0.8em;
            color: #ff8800;
        }

        #questionContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 2;
            text-align: center;
            display: none;
            border: 2px solid #fff;
        }

        #questionContainer h2 {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #fff;
        }

        #questionText {
            font-size: 1em;
            margin-bottom: 15px;
            color: #fff;
        }

        #answerInput {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            width: 80%;
            max-width: 200px;
            font-size: 0.9em;
            background-color: #fff;
            color: #000;
        }

        #checkAnswerButton {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }

        #checkAnswerButton:hover {
            background-color: #367c39;
        }

        #messageContainer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1;
            color: #fff;
            font-size: 0.8em;
            display: none;
        }

        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3;
        }

        .game-over-content {
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #fff;
        }

        .game-over-title {
            font-size: 1.5em;
            color: #ff0000;
            margin-bottom: 10px;
        }

        .game-over-text {
            font-size: 1em;
            color: #fff;
            margin-bottom: 15px;
        }

        .restart-button {
            padding: 10px 20px;
            background-color: #00B8D4;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }

        .restart-button:hover {
            background-color: #00869e;
        }

        @media screen and (max-width: 600px) {
            #instructions {
                font-size: 0.6em;
                padding: 8px;
            }
            #fuelDisplay {
                font-size: 0.6em;
                padding: 8px;
            }
            #questionContainer h2 {
                font-size: 1em;
            }
            #questionText {
                font-size: 0.9em;
            }
            #answerInput {
                font-size: 0.8em;
                padding: 6px;
            }
            #checkAnswerButton {
                font-size: 0.8em;
                padding: 8px 15px;
            }
            .game-over-title {
                font-size: 1.2em;
            }
            .game-over-text {
                font-size: 0.9em;
            }
            .restart-button {
                font-size: 0.8em;
                padding: 8px 15px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="instructions">Use WASD to move, mouse to look around. Fly towards planets. Refuel by answering questions!</div>
    <div id="fuelDisplay">Fuel: 100%</div>
    <div id="questionContainer">
        <h2>Refuel!</h2>
        <div id="questionText"></div>
        <input type="number" id="answerInput" placeholder="Enter your answer">
        <button id="checkAnswerButton">Check Answer</button>
    </div>
    <div id="messageContainer"></div>
    <div class="game-over-overlay">
        <div class="game-over-content">
            <h2 class="game-over-title">Game Over</h2>
            <p class="game-over-text">Out of fuel!</p>
            <button class="restart-button">Restart</button>
        </div>
    </div>
    <div id="planetInfo" style="position: absolute; top: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px; border-radius: 5px; z-index: 1; display: none;">
        <h2 id="planetName"></h2>
        <img id="planetImage" src="" alt="Planet Image" style="max-width: 100px; max-height: 100px;">
        <p id="planetDescription"></p>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const questionContainer = document.getElementById('questionContainer');
        const questionText = document.getElementById('questionText');
        const answerInput = document.getElementById('answerInput');
        const checkAnswerButton = document.getElementById('checkAnswerButton');
        const fuelDisplay = document.getElementById('fuelDisplay');
        const messageContainer = document.getElementById('messageContainer');
        const gameOverOverlay = document.querySelector('.game-over-overlay');
        const restartButton = document.querySelector('.restart-button');
        const planetInfo = document.getElementById('planetInfo');
        const planetNameDisplay = document.getElementById('planetName');
        const planetImageDisplay = document.getElementById('planetImage');
        const planetDescriptionDisplay = document.getElementById('planetDescription');

        let rocket;
        let planets = [];
        let stars;
        let fuel = 100;
        let isFuelEmpty = false;
        let currentQuestion;
        let correctAnswers = 0;
        let gameStarted = false;
        let controls;
        let cameraTarget = new THREE.Vector3(0, 0, -5);
        let introTimeout;
        let planetNames = ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];
        let planetColors = [0xA9A9A9, 0xFFD700, 0xFF4500, 0xFF8C00, 0xF4A460, 0xAFEEEE4, 0x4169E1];
        let ring;
        let randomPlanets = [];
        let beyondRing = false;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        const movementSpeed = 0.5;
        let rocketSpeed = 0.2;  // Increased rocket speed
        const cameraFollowSpeed = 0.05;
        let distanceTravelled = 0;
        const ringDistance = 800;

        // Screen resize
        function resizeRendererToDisplaySize(renderer) {
            try {
                const canvas = renderer.domElement;
                const width = window.innerWidth;
                const height = window.innerHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                    renderer.setSize(width, height, false);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                }
                return needResize;
            } catch (error) {
                console.error("Error in resizeRendererToDisplaySize:", error);
                showMessage("Error resizing renderer. Please check console.");
                return false;
            }
        }

        // Function to display messages
        function showMessage(message, duration = 3000) {
            messageContainer.textContent = message;
            messageContainer.style.display = 'block';
            setTimeout(() => {
                messageContainer.style.display = 'none';
            }, duration);
        }

        // Create the rocket
        function createRocket() {
            const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.1, 0.6, 32);
            const noseGeometry = new THREE.ConeGeometry(0.15, 0.4, 32);
            const finGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array([
                0, 0, 0,
                0.2, 0, 0,
                0, 0.4, 0
            ]);
            finGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });
            const noseMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500 });
            const finMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });

            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.y = 0.3;
            const fin1 = new THREE.Mesh(finGeometry, finMaterial);
            fin1.position.set(0.1, -0.2, 0);
            fin1.rotation.y = Math.PI / 2;
            const fin2 = fin1.clone();
            fin2.position.x = -0.1;
            fin2.rotation.y = -Math.PI / 2;

            const rocketGroup = new THREE.Group();
            rocketGroup.add(body);
            rocketGroup.add(nose);
            rocketGroup.add(fin1);
            rocketGroup.add(fin2);

            return rocketGroup;
        }

        // Create a planet
        function createPlanet(radius, color, x, z, name) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const planet = new THREE.Mesh(geometry, material);
            planet.position.set(x, 0, z);
            planet.name = name;
            return planet;
        }

        // Create the stars
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 1.5, sizeAttenuation: true });
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            return stars;
        }

        function createRing() {
            const ringGeometry = new THREE.RingGeometry(ringDistance - 5, ringDistance + 5, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            ringMesh.rotation.x = Math.PI / 2;
            return ringMesh;
        }

        function createRandomPlanet(x, z) {
            const radius = Math.random() * 5 + 3;
            const color = Math.floor(Math.random() * 16777215);
            const planetName = `Random Planet ${randomPlanets.length + 1}`;
            const planet = createPlanet(radius, color, x, z, planetName);
            planet.isRandom = true; // Add a flag to identify random planets
            return planet;
        }

        // Initialize the scene
        function init() {
            try {
                // Scene setup
                renderer.setClearColor(0x000000);
                resizeRendererToDisplaySize(renderer);
                scene.fog = new THREE.Fog(0x000000, 20, 1000);

                // Create and position the rocket
                rocket = createRocket();
                scene.add(rocket);
                rocket.position.set(0, 0, 5);
                rocket.rotation.set(0, Math.PI, 0);

                // Create planets with names and varied colors
                const numPlanets = 7;
                const planetSpacing = 100;
                for (let i = 0; i < numPlanets; i++) {
                    const angle = (i / numPlanets) * Math.PI * 2;
                    const x = Math.cos(angle) * planetSpacing;
                    const z = Math.sin(angle) * planetSpacing - 200;
                    const radius = Math.random() * 5 + 3;
                    planets.push(createPlanet(radius, planetColors[i], x, z, planetNames[i]));
                    scene.add(planets[i]);
                }

                // Create stars
                stars = createStars();
                scene.add(stars);

                ring = createRing();
                scene.add(ring);
                ring.position.y = -5;

                // Set up camera
                camera.position.set(20, 10, 20);
                camera.lookAt(0, 0, 0);

                // Add controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.2;
                controls.enableZoom = true;
                controls.enablePan = false;
                controls.enableKeys = false;
                scene.add(controls.object);

                // Initial instructions display
                showMessage("Use WASD to move, mouse to look around. Fly towards the planets. Refuel by answering questions!", 5000);

                // Set up event listeners
                window.addEventListener('resize', () => {
                    resizeRendererToDisplaySize(renderer);
                });

                document.addEventListener('keydown', (event) => {
                    if (event.key === 'w' || event.key === 'ArrowUp') {
                        moveForward = true;
                    } else if (event.key === 's' || event.key === 'ArrowDown') {
                        moveBackward = true;
                    } else if (event.key === 'a' || event.key === 'ArrowLeft') {
                        moveLeft = true;
                    } else if (event.key === 'd' || event.key === 'ArrowRight') {
                        moveRight = true;
                    }
                });

                document.addEventListener('keyup', (event) => {
                    if (event.key === 'w' || event.key === 'ArrowUp') {
                        moveForward = false;
                    } else if (event.key === 's' || event.key === 'ArrowDown') {
                        moveBackward = false;
                    } else if (event.key === 'a' || event.key === 'ArrowLeft') {
                        moveLeft = false;
                    } else if (event.key === 'd' || event.key === 'ArrowRight') {
                        moveRight = false;
                    }
                });

                checkAnswerButton.addEventListener('click', checkAnswer);
                restartButton.addEventListener('click', restartGame);

                renderer.domElement.addEventListener('click', (event) => {
                    const mouse = new THREE.Vector2();
                    mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                    mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);

                    const intersects = raycaster.intersectObjects(scene.children, false);

                    if (intersects.length > 0) {
                        const clickedObject = intersects[0].object;

                        if (clickedObject instanceof THREE.Mesh && clickedObject.geometry instanceof THREE.SphereGeometry) {
                            displayPlanetInfo(clickedObject);
                        }
                    }
                });

                renderer.domElement.addEventListener('click', () => {
                    if (!gameStarted) {
                        //controls.lock();
                        gameStarted = true;
                        if (introTimeout) {
                            clearTimeout(introTimeout);
                        }
                        messageContainer.style.display = 'none';
                    }
                });

                // Make sure the canvas is added to the body before we try to use it
                document.body.appendChild(renderer.domElement);

                // Start the animation loop
                animate();
            } catch (error) {
                console.error("Initialization error:", error);
                showMessage("Failed to initialize game. Please check console for errors.");
            }
        }

        // Function to generate a random addition question
        function generateQuestion() {
            const num1 = Math.floor(Math.random() * 10) + 1;
            const num2 = Math.floor(Math.random() * 10) + 1;
            const answer = num1 + num2;
            return {
                question: `What is ${num1} + ${num2}?`,
                answer: answer,
            };
        }

        // Function to display the question
        function showQuestion() {
            currentQuestion = generateQuestion();
            questionText.textContent = currentQuestion.question;
            answerInput.value = '';
            questionContainer.style.display = 'block';
            //controls.unlock();
        }

        // Function to check the answer
        function checkAnswer() {
            try {
                const userAnswer = parseInt(answerInput.value);
                if (userAnswer === currentQuestion.answer) {
                    showMessage('Correct! Refueling...');
                    correctAnswers++;
                    fuel = 100;
                    fuelDisplay.textContent = `Fuel: ${Math.round(fuel)}%`;
                    questionContainer.style.display = 'none';
                    //controls.lock();
                    if (correctAnswers >= 3) {
                        gameOver();
                    }
                } else {
                    showMessage('Incorrect! Try again.');
                    fuel = Math.max(0, fuel - 10); // Increased fuel penalty
                    fuelDisplay.textContent = `Fuel: ${Math.round(fuel)}%`;
                    if (fuel <= 0) {
                        isFuelEmpty = true;
                        showQuestion();
                    }
                }
            } catch (error) {
                console.error("Error checking answer:", error);
                showMessage("Error checking answer. Please try again.");
            }
        }

        function gameOver() {
            gameStarted = false;
            gameOverOverlay.style.display = 'flex';
            //controls.unlock();
        }

        function restartGame() {
            fuel = 100;
            isFuelEmpty = false;
            correctAnswers = 0;
            fuelDisplay.textContent = `Fuel: ${Math.round(fuel)}%`;
            gameOverOverlay.style.display = 'none';
            questionContainer.style.display = 'none';
            rocket.position.set(0, 0, 5);
            rocket.rotation.set(0, Math.PI, 0);
            camera.position.set(0, 3, 10);
            camera.lookAt(0, 0, 0);
            planets.forEach(planet => scene.remove(planet));
            planets = [];
            randomPlanets.forEach(planet => scene.remove(planet));
            randomPlanets = [];
            beyondRing = false;
            distanceTravelled = 0;
            init();
        }

        // Animation loop
        function animate() {
            try {
                if (!renderer || !scene || !camera) {
                    console.error("Renderer, scene, or camera is not initialized.");
                    showMessage("Game is not properly initialized.  Check console for errors.");
                    return;
                }
                requestAnimationFrame(animate);
                resizeRendererToDisplaySize(renderer);

                if (gameStarted) {
                    stars.position.z = camera.position.z - 50;

                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    direction.y = 0;  // Keep movement horizontal
                    direction.normalize();

                    const moveDistance = rocketSpeed;

                    if (moveForward) {
                        rocket.position.add(direction.clone().multiplyScalar(moveDistance));
                        fuel -= 0.1;
                        distanceTravelled += moveDistance;
                    }
                    if (moveBackward) {
                        rocket.position.add(direction.clone().multiplyScalar(-moveDistance * 0.5));
                        fuel -= 0.1;
                        distanceTravelled += moveDistance * 0.5;
                    }
                    if (moveLeft) {
                        const strafeVector = new THREE.Vector3();
                        strafeVector.crossVectors(new THREE.Vector3(0, 1, 0), direction);
                        strafeVector.normalize();
                        rocket.position.add(strafeVector.multiplyScalar(-moveDistance * 0.5));
                        fuel -= 0.05;
                        distanceTravelled += moveDistance * 0.5;
                    }
                    if (moveRight) {
                        const strafeVector = new THREE.Vector3();
                        strafeVector.crossVectors(new THREE.Vector3(0, 1, 0), direction);
                        strafeVector.normalize();
                        rocket.position.add(strafeVector.multiplyScalar(moveDistance * 0.5));
                        fuel -= 0.05;
                        distanceTravelled += moveDistance * 0.5;
                    }

                    fuel = Math.max(0, fuel);
                    fuelDisplay.textContent = `Fuel: ${Math.round(fuel)}%`;

                    let closestPlanet = null;
                    let minDistance = Infinity;
                    for (const planet of planets) {
                        const distance = rocket.position.distanceTo(planet.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestPlanet = planet;
                        }
                    }

                    if (closestPlanet && minDistance < 15) {
                        showMessage(`Arrived at ${closestPlanet.name}!`);
                        if (fuel < 100) {
                            showQuestion();
                        }
                    }

                    const targetPosition = new THREE.Vector3();
                    rocket.getWorldPosition(targetPosition);

                    if (distanceTravelled > ringDistance && !beyondRing) {
                        beyondRing = true;
                        showMessage("You have passed the ring!  Entering uncharted space...");
                        for (let i = 0; i < 20; i++) {
                            const x = (Math.random() - 0.5) * 1000 + targetPosition.x;
                            const z = (Math.random() - 0.5) * 1000 + targetPosition.z;
                            const newPlanet = createRandomPlanet(x, z);
                            randomPlanets.push(newPlanet);
                            scene.add(newPlanet);
                        }
                    }
                    if (beyondRing) {
                        for (let i = 0; i < randomPlanets.length; i++) {
                            const planet = randomPlanets[i];
                            const distance = rocket.position.distanceTo(planet.position);
                            if (distance < 15) {
                                showMessage(`Arrived at ${planet.name}!`);
                                if (fuel < 100) {
                                    showQuestion();
                                }
                            }
                        }
                    }
                }
                const cameraOffset = new THREE.Vector3(0, 1, -3); // Adjust these values to change the camera's position
                cameraOffset.applyQuaternion(rocket.quaternion);
                camera.position.copy(rocket.position).add(cameraOffset);

                const targetOffset = new THREE.Vector3(0, 0, 5); // Adjust this value to change how far ahead the camera looks
                targetOffset.applyQuaternion(rocket.quaternion);
                controls.target.copy(rocket.position).add(targetOffset);

                controls.update();
                renderer.render(scene, camera);
            } catch (error) {
                console.error("Error in animation", error);
            }
        }

        function displayPlanetInfo(planet) {
            planetNameDisplay.textContent = planet.name;
            planetInfo.style.display = 'block';
            if (planet.isRandom) {
                planetImageDisplay.src = '';
                planetDescriptionDisplay.textContent = 'This is a randomly generated planet.';
            } else {
                planetImageDisplay.src = 'planet.jpg';
                planetDescriptionDisplay.textContent = 'This is a planet.';
            }
        }
        init();
    </script>
</body>
</html>
