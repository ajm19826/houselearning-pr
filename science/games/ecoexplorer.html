<!DOCTYPE html>
<html>

<head>
    <title>3D Ecosystem Explorer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }

        canvas {
            display: block;
        }

        #energyBar {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 200px;
            height: 20px;
            border: 2px solid black;
            z-index: 1000; /* Ensure it's above other elements */
        }

        #energy {
            width: 100%;
            height: 100%;
            background-color: green;
        }
        #schoolToolbar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(200, 200, 200, 0.8);
            padding: 10px;
            text-align: center;
            z-index: 1000;
            display: none; /* Hidden by default */
        }

        #schoolToolbar button {
            padding: 8px 16px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
        }
        #questionOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            z-index: 1001; /* Sit on top of everything */
        }

        #questionContainer {
            background-color: rgba(50, 50, 50, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
        }

        #homeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(200, 200, 200, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1002;
        }

        #homeScreen button {
            padding: 12px 24px;
            margin: 10px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            border: none;
        }

        #homeScreen button:hover {
            background-color: #45a049;
        }

        #classCodeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(200, 200, 200, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1003;
        }

        #classCodeScreen input {
            padding: 10px;
            font-size: 16px;
            margin-bottom: 10px;
            border-radius: 5px;
            border: 1px solid #aaa;
            width: 200px;
        }

        #classCodeScreen button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            background-color: #008CBA;
            color: white;
            border: none;
        }

        #classCodeScreen button:hover {
            background-color: #007ba7;
        }

        #classCodeScreen a {
            margin-top: 10px;
            font-size: 14px;
            color: #008CBA;
            text-decoration: none;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(220, 220, 220, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        #inventory button {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            cursor: pointer;
            border: none;
        }

        .blockButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }

        .blockButton button {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            cursor: pointer;
            border: none;
        }
        .disabled {
            pointer-events: none;
            opacity: 0.6;
        }

    </style>
</head>

<body>  
    <!--sKIN-->
    <div id="skinMenu" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(220, 220, 220, 0.7); padding: 20px; border-radius: 5px; display: none; flex-direction: column; align-items: center; z-index: 1001;">
    <p>Select a Skin Color:</p>
    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
        <button data-color="red" style="background-color: red; width: 30px; height: 30px; border-radius: 5px; cursor: pointer; border: none;"></button>
        <button data-color="green" style="background-color: green; width: 30px; height: 30px; border-radius: 5px; cursor: pointer; border: none;"></button>
        <button data-color="blue" style="background-color: blue; width: 30px; height: 30px; border-radius: 5px; cursor: pointer; border: none;"></button>
        <button data-color="black" style="background-color: black; width: 30px; height: 30px; border-radius: 5px; cursor: pointer; border: none;"></button>
        <button data-color="white" style="background-color: white; width: 30px; height: 30px; border-radius: 5px; cursor: pointer; border: none;"></button>
        <button data-color="purple" style="background-color: purple; width: 30px; height: 30px; border-radius: 5px; cursor: pointer; border: none;"></button>
        <button data-color="pink" style="background-color: pink; width: 30px; height: 30px; border-radius: 5px; cursor: pointer; border: none;"></button>
    </div>
    <button id="takePictureButton" style="padding: 8px 16px; margin: 5px; font-size: 16px; cursor: pointer;">Take a Picture</button>
    <button id="closeSkinMenu" style="padding: 8px 16px; margin: 5px; font-size: 16px; cursor: pointer;">Close</button>
    <button id="chooseImageSource" style="padding: 8px 16px; margin: 5px; font-size: 16px; cursor: pointer;">Choose Image Source</button>
    <input type="file" id="imageUpload" accept="image/*" style="display: none;">
    <video id="cameraView" width="320" height="240" autoplay style="display: none;"></video>
    <button id="captureButton" style="padding: 8px 16px; margin: 5px; font-size: 16px; cursor: pointer; display: none;">Capture</button>
    <canvas id="capturedImage" width="320" height="240" style="display: none;"></canvas></div>
<script>
    const chooseImageSource = document.getElementById('chooseImageSource');
const cameraView = document.getElementById('cameraView');
const captureButton = document.getElementById('captureButton');
const capturedImageCanvas = document.getElementById('capturedImage');
const capturedImageContext = capturedImageCanvas.getContext('2d');
let stream;
chooseImageSource.addEventListener('click', () => {
        const source = prompt("Choose image source: 'file' or 'camera'");
        if (source === 'file') {
            imageUpload.click();
        } else if (source === 'camera') {
            startCamera();
        }
    });

    async function startCamera() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: false
            });
            cameraView.srcObject = stream;
            cameraView.style.display = 'block';
            captureButton.style.display = 'block';
        } catch (err) {
            console.error("Error accessing camera:", err);
        }
    }

    captureButton.addEventListener('click', () => {
        capturedImageContext.drawImage(cameraView, 0, 0, capturedImageCanvas.width, capturedImageCanvas.height);
        stopCamera();
        const texture = new THREE.Texture(capturedImageCanvas);
        texture.needsUpdate = true;
        character.material = new THREE.MeshBasicMaterial({
            map: texture
        });
        character.material.needsUpdate = true;
    });

    function stopCamera() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            cameraView.srcObject = null;
            cameraView.style.display = 'none';
            captureButton.style.display = 'none';
        }
    }
    const skinMenu = document.getElementById('skinMenu');
    const takePictureButton = document.getElementById('takePictureButton');
    const imageUpload = document.getElementById('imageUpload');
    const closeSkinMenu = document.getElementById('closeSkinMenu');
    let originalCharacterMaterial;
    let skinMenuOpen = false;

    document.addEventListener('keydown', (event) => {
        console.log("Key pressed:", event.key); // Check which key is pressed
        switch (event.key) {
            case 'ArrowUp':
                moveForward = true;
                break;
            case 'ArrowDown':
                moveBackward = true;
                break;
            case 'ArrowLeft':
                moveLeft = true;
                break;
            case 'ArrowRight':
                moveRight = true;
                break;
            case 's':
                console.log("S key pressed - Toggling skin menu");
                toggleSkinMenu();
                break;
        }
    });

    function toggleSkinMenu() {
        skinMenuOpen = !skinMenuOpen;
        console.log("Skin menu open:", skinMenuOpen);
        skinMenu.style.display = skinMenuOpen ? 'flex' : 'none';
        if (skinMenuOpen) {
            console.log("Storing original material");
            originalCharacterMaterial = character.material;
        } else {
            console.log("Restoring original material");
            character.material = originalCharacterMaterial;
            character.material.needsUpdate = true;
        }
    }

    skinMenu.addEventListener('click', (event) => {
        if (event.target.tagName === 'BUTTON' && event.target.dataset.color) {
            const color = event.target.dataset.color;
            console.log("Color button clicked:", color);
            character.material = new THREE.MeshLambertMaterial({
                color: color
            });
            character.material.needsUpdate = true; // Important!
        }
    });

    takePictureButton.addEventListener('click', () => {
        console.log("Take picture button clicked");
        imageUpload.click();
    });

    imageUpload.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                console.log("Image loaded");
                const texture = new THREE.TextureLoader().load(e.target.result);
                character.material = new THREE.MeshBasicMaterial({
                    map: texture
                });
                character.material.needsUpdate = true;
            };
            reader.readAsDataURL(file);
        }
    });

    closeSkinMenu.addEventListener('click', () => {
        console.log("Close skin menu clicked");
        toggleSkinMenu(false); // Pass false to indicate closing without reset
    });

    function toggleSkinMenu(reset = true) {
        skinMenuOpen = !skinMenuOpen;
        console.log("Skin menu open:", skinMenuOpen);
        skinMenu.style.display = skinMenuOpen ? 'flex' : 'none';
        if (skinMenuOpen) {
            console.log("Storing original material");
            originalCharacterMaterial = character.material.clone(); // Clone the material
        } else {
            console.log("Restoring original material");
            if (reset) {
                character.material = originalCharacterMaterial;
                character.material.needsUpdate = true;
            }
        }
    }
</script>
<!--sKIN-->
    <div id="schoolToolbar">
        <button id="classmatesButton">Classmates</button>
        <button id="logoutButton">Log Out</button>
        <button id="messageClassButton">Message Class</button>
    </div>
    <div id="energyBar" class="disabled">
        <div id="energy"></div>
    </div>
    <div id="questionOverlay" class="disabled">
        <div id="questionContainer">
            <p id="questionText"></p>
            <input type="text" id="answerInput">
            <button id="submitAnswer">Submit</button>
        </div>
    </div>
    <div id="homeScreen">
        <button id="schoolButton">School</button>
        <button id="homeButton">Home</button>
    </div>
    <div id="classCodeScreen" style="display: none;">
        <input type="text" id="classCodeInput" placeholder="Enter Class Code">
        <button id="classCodeSubmit">Submit</button>
        <a href="#" id="noClassCode">No class code</a>
    </div>
    <div id="inventory" style="display: none;">
        <button style="background-color: red;" data-color="red"></button>
        <button style="background-color: green;" data-color="green"></button>
        <button style="background-color: blue;" data-color="blue"></button>
        <button style="background-color: yellow;" data-color="yellow"></button>
        <button style="background-color: purple;" data-color="purple"></button>
        <button style="background-color: orange;" data-color="orange"></button>
    </div>
    <div class="blockButton" style="display: none;">
        <button id="treeButton">Tree</button>
        <button id="rockButton">Rock</button>
        <button id="animalButton">Animal</button>
        <button id="pondButton">Pond</button>
        <button id="bearButton">Bear</button>
        <button id="humanButton">Human</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const schoolToolbar = document.getElementById('schoolToolbar');
        const classmatesButton = document.getElementById('classmatesButton');
        const logoutButton = document.getElementById('logoutButton');
        const messageClassButton = document.getElementById('messageClassButton');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        let directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
        const groundMaterial = new THREE.MeshLambertMaterial({
            color: 0x228B22
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        let selectedColor = 'red';
        let buildMode = false;

        const inventory = document.getElementById('inventory');
        inventory.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                selectedColor = event.target.dataset.color;
            }
        });

        document.addEventListener('click', (event) => {
    if (event.button === 0 && buildMode) {
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(blocks);
        if (intersects.length > 0) {
            const point = intersects[0].point;
            const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
            const blockMaterial = new THREE.MeshLambertMaterial({
                color: selectedColor
            });
            const block = new THREE.Mesh(blockGeometry, blockMaterial);
            block.position.set(point.x, intersects[0].object.position.y + 1, point.z);
            scene.add(block);
            blocks.push(block); // Add this line
        } else {
            const intersectsGround = raycaster.intersectObjects([ground]);
            if (intersectsGround.length > 0) {
                const point = intersectsGround[0].point;
                const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
                const blockMaterial = new THREE.MeshLambertMaterial({
                    color: selectedColor
                });
                const block = new THREE.Mesh(blockGeometry, blockMaterial);
                block.position.set(point.x, 0.5, point.z);
                scene.add(block);
                blocks.push(block); // Add this line
            }
        }
    }
});

        const characterGeometry = new THREE.BoxGeometry(1, 1, 1);
        const characterMaterial = new THREE.MeshLambertMaterial({
            color: 0xff0000
        });
        const character = new THREE.Mesh(characterGeometry, characterMaterial);
        scene.add(character);

        camera.position.z = 5;
        camera.position.y = 3;
        camera.lookAt(character.position);

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        const moveSpeed = 0.1;

        let energy = 100;
        const energyBar = document.getElementById('energy');
        const energyLoss = 0.1;

        const questionOverlay = document.getElementById('questionOverlay');
        const questionText = document.getElementById('questionText');
        const answerInput = document.getElementById('answerInput');
        const submitAnswer = document.getElementById('submitAnswer');

        const scienceQuestions = [{
                question: "What is the chemical symbol for water?",
                answer: "H2O"
            },
            {
                question: "What is the largest planet in our solar system?",
                answer: "Jupiter"
            },
            {
                question: "What is the process by which plants make their own food?",
                answer: "Photosynthesis"
            },
            {
                question: "What is the speed of light in a vacuum?",
                answer: "299792458 m/s"
            },
            {
                question: "What is the powerhouse of the cell?",
                answer: "Mitochondria"
            },
            {
                question: "What is the scientific name for humans?",
                answer: "Homo sapiens"
            },
            {
                question: "What force pulls objects towards the Earth?",
                answer: "Gravity"
            },
            {
                question: "What is the boiling point of water in Celsius?",
                answer: "100"
            },
            {
                question: "What gas do plants absorb from the atmosphere?",
                answer: "Carbon dioxide"
            },
            {
                question: "What is the smallest unit of matter?",
                answer: "Atom"
            },
        ];

        let questionsAsked = 0;
        let correctAnswerCount = 0;

        function askQuestions() {
            questionOverlay.style.display = 'flex';
            questionOverlay.classList.remove('disabled');
            const selectedQuestions = [];
            for (let i = 0; i < 3; i++) {
                selectedQuestions.push(scienceQuestions[Math.floor(Math.random() * scienceQuestions.length)]);
            }
            let questionIndex = 0;

            function showQuestion() {
                if (questionIndex < 3) {
                    questionText.textContent = selectedQuestions[questionIndex].question;
                    answerInput.value = '';
                } else {
                    if (correctAnswerCount >= 2) {
                        energy = 100;
                    }
                    questionOverlay.style.display = 'none';
                    questionOverlay.classList.add('disabled');
                    questionsAsked = 0;
                    correctAnswerCount = 0;
                }
            }
            showQuestion();

            submitAnswer.onclick = function () {
                if (answerInput.value.toLowerCase() === selectedQuestions[questionIndex].answer.toLowerCase()) {
                    correctAnswerCount++;
                }
                questionIndex++;
                showQuestion();
            };
        }

        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                    moveLeft = true;
                    break;
                case 'ArrowRight':
                    moveRight = true;
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                    moveRight = false;
                    break;
            }
        });

        let isDragging = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };
        const cameraRotationSpeed = 0.002;

        document.addEventListener('mousedown', (event) => {
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.addEventListener('mousemove', (event) => {
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y,
                };

                camera.rotation.x -= deltaMove.y * cameraRotationSpeed;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        });

        function createTree(x, z) {
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 3, 32);
            const trunkMaterial = new THREE.MeshLambertMaterial({
                color: 0x8B4513
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 1.5, z);
            scene.add(trunk);

            const leavesGeometry = new THREE.ConeGeometry(2, 4, 32);
            const leavesMaterial = new THREE.MeshLambertMaterial({
                color: 0x006400
            });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(x, 4, z);
            scene.add(leaves);

            if (Math.random() > .5) {
                const leaves2Geometry = new THREE.ConeGeometry(1.5, 3, 32);
                const leaves2Material = new THREE.MeshLambertMaterial({
                    color: 0x006400
                });
                const leaves2 = new THREE.Mesh(leaves2Geometry, leaves2Material);
                leaves2.position.set(x, 2.5, z);
                scene.add(leaves2);
            }
            return trunk;
        }

        function createRock(x, z) {
            const rockGeometry = new THREE.SphereGeometry(0.7, 16, 16);
            const rockMaterial = new THREE.MeshLambertMaterial({
                color: 0x808080
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, 0.35, z);
            scene.add(rock);
            return rock;
        }

        function createAnimal(x, z) {
            const animalType = Math.random() < 0.5 ? 'cow' : 'pig';
            const animal = new THREE.Group();

            let headColor, bodyColor, legColor, smileColor = 'black';
            if (animalType === 'cow') {
                headColor = 0x8B4513; // brown
                bodyColor = 0x8B4513;
                legColor = 0x8B4513;
                smileColor = 'white';
            } else {
                headColor = 0xFFB6C1; // pink
                bodyColor = 0xFFB6C1;
                legColor = 0xFFB6C1;
            }

            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({
                color: headColor
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0.5, 0);
            animal.add(head);

            const bodyGeometry = new THREE.BoxGeometry(1, 0.6, 1.5);
            const bodyMaterial = new THREE.MeshLambertMaterial({
                color: bodyColor
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            animal.add(body);

            const legGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
            const legMaterial = new THREE.MeshLambertMaterial({
                color: legColor
            });
            const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontLeftLeg.position.set(-0.4, -0.5, 0.5);
            animal.add(frontLeftLeg);
            const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontRightLeg.position.set(0.4, -0.5, 0.5);
            animal.add(frontRightLeg);
            const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            backLeftLeg.position.set(-0.4, -0.5, -0.5);
            animal.add(backLeftLeg);
            const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            backRightLeg.position.set(0.4, -0.5, -0.5);
            animal.add(backRightLeg);

            if (animalType === 'cow') {
                const spotGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const spotMaterial = new THREE.MeshLambertMaterial({
                    color: 'white'
                });
                const spot1 = new THREE.Mesh(spotGeometry, spotMaterial);
                spot1.position.set(0.3, 0.2, 0.3);
                animal.add(spot1);
                const spot2 = new THREE.Mesh(spotGeometry, spotMaterial);
                spot2.position.set(-0.3, 0.1, -0.3);
                animal.add(spot2);
            } else {
                const tailGeometry = new THREE.TorusGeometry(0.2, 0.1, 16, 100);
                const tailMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFB6C1
                });
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.set(0, 0.2, -1);
                tail.rotation.x = Math.PI / 2;
                animal.add(tail);
            }

            const smileCanvas = document.createElement('canvas');
            const smileContext = smileCanvas.getContext('2d');
            smileCanvas.width = 64;
            smileCanvas.height = 32;
            smileContext.beginPath();
            smileContext.arc(32, 20, 10, 0, Math.PI, false);
            smileContext.strokeStyle = smileColor;
            smileContext.lineWidth = 2;
            smileContext.stroke();

            const smileTexture = new THREE.CanvasTexture(smileCanvas);
            const smileMaterial = new THREE.MeshBasicMaterial({
                map: smileTexture,
                transparent: true
            });
            const smileGeometry = new THREE.PlaneGeometry(0.5, 0.25);
            const smileMesh = new THREE.Mesh(smileGeometry, smileMaterial);
            smileMesh.position.set(0, 0.6, 0.6);
            animal.add(smileMesh);

            animal.position.set(x, 0.3, z);
            animal.animalData = {
                direction: Math.random() * Math.PI * 2,
                speed: 0.03,
                state: 'wandering',
                target: null,
                targetDistance: 5,
            };
            scene.add(animal);
            return animal;
        }

        function createBird(x, y, z) {
            const birdGeometry = new THREE.ConeGeometry(0.3, 1.2, 3);
            const birdMaterial = new THREE.MeshLambertMaterial({
                color: 0xFFFF00
            });
            const bird = new THREE.Mesh(birdGeometry, birdMaterial);
            bird.rotation.x = Math.PI / 2;
            bird.position.set(x, y, z);
            scene.add(bird);

            bird.birdData = {
                direction: Math.random() * Math.PI * 2,
                speed: 0.05,
                altitude: y,
                altitudeVariation: 0.5,
                altitudeChangeSpeed: 0.01,
            };
            return bird;
        }

        function createGrass(x, z) {
            const grassGeometry = new THREE.PlaneGeometry(0.2, 0.5);
            const grassMaterial = new THREE.MeshLambertMaterial({
                color: 0x003300,
                side: THREE.DoubleSide
            });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.set(x, 0.01, z);
            scene.add(grass);
            return grass;
        }

        function createFlower(x, z) {
            const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 32);
            const stemMaterial = new THREE.MeshLambertMaterial({
                color: 0xFFFF00
            });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.set(x, 0.15, z);
            scene.add(stem);

            const leafGeometry = new THREE.ConeGeometry(0.1, 0.2, 3);
            const leafMaterial = new THREE.MeshLambertMaterial({
                color: 0x006400
            });
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.position.set(x, 0.1, z);
            leaf.rotation.x = Math.PI / 2;
            scene.add(leaf);

            const flowerGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const flowerMaterial = new THREE.MeshLambertMaterial({
                color: 0xFF0000
            });
            const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
            flower.position.set(x, 0.3, z);
            scene.add(flower);
            flower.isFlower = true;
            return flower;
        }

        function createPond(x, z) {
            const pondGeometry = new THREE.CylinderGeometry(6, 6, 1, 32);
            const pondMaterial = new THREE.MeshLambertMaterial({
                color: 0x0000FF
            });
            const pond = new THREE.Mesh(pondGeometry, pondMaterial);
            pond.position.set(x, 0.5, z);
            scene.add(pond);

            const fishArray = [];
            for (let i = 0; i < 10; i++) {
                const fishX = x + (Math.random() - 0.5) * 8;
                const fishZ = z + (Math.random() - 0.5) * 8;
                const fishY = Math.random() * 0.5 + 0.5;
                fishArray.push(createFish(fishX, fishY, fishZ));
            }

            // Audio setup
            const listener = new THREE.AudioListener();
            camera.add(listener);
            const sound = new THREE.Audio(listener);
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load('https://houselearning.github.io/home/assets/ecoexplorer/one-pound-fish.mp3', function (buffer) {
                sound.setBuffer(buffer);
                sound.setLoop(true);
                sound.setVolume(0);
            });

            pond.sound = sound;
            pond.fishArray = fishArray;
            return pond;
        }

        function createFish(x, y, z) {
            const fishGeometry = new THREE.ConeGeometry(0.2, 0.5, 32);
            const fishMaterial = new THREE.MeshLambertMaterial({
                color: 0xFFA500
            });
            const fish = new THREE.Mesh(fishGeometry, fishMaterial);
            fish.position.set(x, y, z);
            fish.rotation.y = Math.random() * Math.PI * 2;
            scene.add(fish);
            return fish;
        }

        function createBear(x, z) {
            const bear = new THREE.Group();

            const headGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({
                color: 0x8B4513
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.1, 0);
            bear.add(head);

            const earGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const earMaterial = new THREE.MeshLambertMaterial({
                color: 0xFF0000
            });
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(-0.5, 1.7, 0);
            bear.add(leftEar);
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.5, 1.7, 0);
            bear.add(rightEar);

            const bodyGeometry = new THREE.BoxGeometry(1, 1.2, 1);
            const bodyMaterial = new THREE.MeshLambertMaterial({
                color: 0x8B4513
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0, 0);
            bear.add(body);

            const legGeometry = new THREE.BoxGeometry(0.3, 0.5, 0.3);
            const legMaterial = new THREE.MeshLambertMaterial({
                color: 0x8B4513
            });
            const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontLeftLeg.position.set(-0.35, -0.85, 0.3);
            bear.add(frontLeftLeg);
            const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontRightLeg.position.set(0.35, -0.85, 0.3);
            bear.add(frontRightLeg);
            const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            backLeftLeg.position.set(-0.35, -0.85, -0.3);
            bear.add(backLeftLeg);
            const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            backRightLeg.position.set(0.35, -0.85, -0.3);
            bear.add(backRightLeg);

            bear.position.set(x, 0.6, z);

            bear.bearData = {
                direction: Math.random() * Math.PI * 2,
                speed: 0.02,
                state: 'wandering',
                target: null,
                targetDistance: 2,
                eating: false,
                eatingTimer: 0,
            };

            scene.add(bear);
            return bear;
        }

        function createHuman(x, z) {
            const human = new THREE.Group();
            const textureLoader = new THREE.TextureLoader();
            const textureFile = Math.random() < 0.5 ? 'https://www.addedvaluation.co.nz/wp-content/uploads/2015/10/Jo-Full-Body-transparent.png' : 'https://png.pngtree.com/png-vector/20230905/ourmid/pngtree-regular-guy-full-body-shot-good-guy-png-image_9939317.png';
            textureLoader.load(textureFile, (texture) => {
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                const geometry = new THREE.PlaneGeometry(1, 2);
                const mesh = new THREE.Mesh(geometry, material);
                human.add(mesh);
            });
            human.position.set(x, 1, z);
            human.humanData = {
                direction: Math.random() * Math.PI * 2,
                speed: 0.04,
            };
            scene.add(human);
            return human;
        }

        const animals = [];
        const birds = [];
        const ponds = [];
        const bears = [];
        const humans = [];
        let createdObjects = [];

        function clearObjects(){
            createdObjects.forEach(obj => {
                scene.remove(obj);
            });
            animals.length = 0;
            birds.length = 0;
            ponds.length = 0;
            bears.length = 0;
            humans.length = 0;
            createdObjects = [];
        }

        function spawnObjects() {
            const x = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            const xNear = character.position.x + (Math.random() - 0.5) * 20;
            const zNear = character.position.z + (Math.random() - 0.5) * 20;

            const rand = Math.random();
            let newObject;
            if (rand > 0.8) {
                newObject = createHuman(x, z);
                humans.push(newObject);
            } else if (rand > 0.65) {
                newObject = createTree(x, z);
                createdObjects.push(newObject);
                newObject = createTree(xNear, zNear);
                createdObjects.push(newObject);
            } else if (rand > 0.5) {
                newObject = createRock(x, z);
                createdObjects.push(newObject);
                newObject = createRock(xNear, zNear);
                createdObjects.push(newObject);
            } else if (rand > 0.35) {
                newObject = createAnimal(x, z);
                animals.push(newObject);
                newObject = createAnimal(xNear, zNear);
                animals.push(newObject);
            } else if (rand > 0.2) {
                newObject = createFlower(x, z);
                createdObjects.push(newObject);
                newObject = createFlower(xNear, zNear);
                createdObjects.push(newObject);
            } else if (rand > 0.05) {
                newObject = createPond(x,z);
                ponds.push(newObject);
            } else if (rand <= 0.4) {
                newObject = createBear(x, z);
                bears.push(newObject);
                newObject = createBear(xNear, zNear);
                bears.push(newObject);
            }
            if (rand <= 0.8) {
                newObject = createBird(x, 5 + Math.random() * 3, z);
                birds.push(newObject);
                newObject = createBird(xNear, 5 + Math.random() * 3, zNear);
                birds.push(newObject);
                newObject = createGrass(x, z);
                createdObjects.push(newObject);
                newObject = createGrass(xNear, zNear);
                createdObjects.push(newObject);
            }
            if (newObject){
                createdObjects.push(newObject);
            }
        }

        let lastSpawnTime = 0;
        const spawnInterval = 50;
        let isDay = true;
        let timeOfDayChange = Date.now();
        const dayNightCycle = 60000;

        const homeScreen = document.getElementById('homeScreen');
        const schoolButton = document.getElementById('schoolButton');
        const homeButton = document.getElementById('homeButton');
        const classCodeScreen = document.getElementById('classCodeScreen');
        const classCodeInput = document.getElementById('classCodeInput');
        const classCodeSubmit = document.getElementById('classCodeSubmit');
        const noClassCodeLink = document.getElementById('noClassCode');
        const energyBarElement = document.getElementById('energyBar');
        const inventoryElement = document.getElementById('inventory');
        const blockButtonsElement = document.querySelector('.blockButton');

        schoolButton.addEventListener('click', () => {
            homeScreen.style.display = 'none';
            classCodeScreen.style.display = 'flex';
        });

        homeButton.addEventListener('click', () => {
            startGame(false);
        });

        classCodeSubmit.addEventListener('click', () => {
            const classCode = classCodeInput.value;
            if (classCode.trim() !== '') {
                alert(`Joining class with code: ${classCode}`);
                startGame(true);
            } else {
                alert('Please enter a class code.');
            }
        });

        noClassCodeLink.addEventListener('click', () => {
    startGame(false);
});
classmatesButton.addEventListener('click', () => {
            alert('Only you are in the class');
        });

        logoutButton.addEventListener('click', () => {
            alert('Logging out');
            // Add code to reset the game state or redirect to a login page
        });

        messageClassButton.addEventListener('click', () => {
            const message = prompt('Enter your message:');
            if (message) {
                alert(`Sending message: ${message} to the class!`);
                // Add code to send the message to other players in the class
            }
        });
        let blocks = []; // Add this line at the top of your script, with other variable declarations
        function startGame(isSchoolMode) {
            classCodeScreen.style.display = 'none';
            homeScreen.style.display = 'none';
            energyBarElement.classList.remove('disabled');
            if (!isSchoolMode) {
                schoolToolbar.style.display = 'block'; // Show toolbar
        inventoryElement.style.display = 'flex';
        blockButtonsElement.style.display = 'flex';
        buildMode = true; // Set buildMode to true for home mode
    } else {
        schoolToolbar.style.display = 'none'; // Hide toolbar
        questionOverlay.classList.remove('disabled');
        buildMode = false; // Ensure buildMode is false for school mode
    }
            document.body.style.backgroundColor = '#87CEEB';
            spawnObjects();
            animate();
        }

        document.getElementById('treeButton').addEventListener('click', () => {
            const x = character.position.x + (Math.random() - 0.5) * 5;
            const z = character.position.z + (Math.random() - 0.5) * 5;
            const tree = createTree(x, z);
            scene.add(tree);
            createdObjects.push(tree);
        });
        document.getElementById('rockButton').addEventListener('click', () => {
            const x = character.position.x + (Math.random() - 0.5) * 5;
            const z = character.position.z + (Math.random() - 0.5) * 5;
            const rock = createRock(x, z);
            scene.add(rock);
            createdObjects.push(rock);
        });
        document.getElementById('animalButton').addEventListener('click', () => {
            const x = character.position.x + (Math.random() - 0.5) * 5;
            const z = character.position.z + (Math.random() - 0.5) * 5;
            const animal = createAnimal(x, z);
            animals.push(animal);
            scene.add(animal);
            createdObjects.push(animal);
        });
        document.getElementById('pondButton').addEventListener('click', () => {
            const x = character.position.x + (Math.random() - 0.5) * 10;
            const z = character.position.z + (Math.random() - 0.5) * 10;
            const pond = createPond(x, z);
            ponds.push(pond);
            scene.add(pond);
            createdObjects.push(pond);
        });

        document.getElementById('bearButton').addEventListener('click', () => {
            const x = character.position.x + (Math.random() - 0.5) * 5;
            const z = character.position.z + (Math.random() - 0.5) * 5;
            const bear = createBear(x, z);
            bears.push(bear);
            scene.add(bear);
            createdObjects.push(bear);
        });

        document.getElementById('humanButton').addEventListener('click', () => {
            const x = character.position.x + (Math.random() - 0.5) * 5;
            const z = character.position.z + (Math.random() - 0.5) * 5;
            const human = createHuman(x, z);
            humans.push(human);
            scene.add(human);
            createdObjects.push(human);
        });

        function animate() {
            requestAnimationFrame(animate);
            handleBlockBreaking(); // Add this line
            handleJumping(); // Add this line
            if (moveForward) {
                character.position.z -= moveSpeed;
                energy -= energyLoss;
            }
            if (moveBackward) {
                character.position.z += moveSpeed;
                energy -= energyLoss;
            }
            if (moveLeft) {
                character.position.x -= moveSpeed;
                energy -= energyLoss;
            }
            if (moveRight) {
                character.position.x += moveSpeed;
                energy -= energyLoss;
            }

            if (energy <= 0) {
                energy = 100;
                askQuestions();
            }

            energyBar.style.width = (energy > 0 ? energy : 0) + '%';

            camera.position.x = character.position.x;
            camera.position.z = character.position.z + 5;
            camera.lookAt(character.position);

            animals.forEach(animal => {
                const data = animal.animalData;

                if (data.state === 'wandering') {
                    animal.position.x += Math.cos(data.direction) * data.speed;
                    animal.position.z += Math.sin(data.direction) * data.speed;

                    if (Math.random() < 0.01) {
                        data.direction += (Math.random() - 0.5) * Math.PI;
                    }

                    if (Math.random() < 0.001) {
                        let closestRock = null;
                        let closestDistance = Infinity;

                        scene.children.forEach(obj => {
                            if (obj !== animal && obj.geometry && obj.geometry.type === "SphereGeometry") {
                                const distance = animal.position.distanceTo(obj.position);
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestRock = obj;
                                }
                            }
                        });
                        if (closestRock) {
                            data.state = 'seeking';
                            data.target = closestRock;
                        }
                    }
                } else if (data.state === 'seeking') {
                    if (data.target) {
                        const targetPosition = data.target.position;
                        const direction = new THREE.Vector3().subVectors(targetPosition, animal.position).normalize();
                        animal.position.x += direction.x * data.speed;
                        animal.position.z += direction.z * data.speed;

                        if (animal.position.distanceTo(targetPosition) < data.targetDistance) {
                            data.state = 'wandering';
                            data.target = null;
                        }
                    } else {
                        data.state = 'wandering';
                    }
                }
            });

            bears.forEach(bear => {
                const data = bear.bearData;

                if (data.eating) {
                    data.eatingTimer += 16;
                    if (data.eatingTimer > 5000) {
                        data.eating = false;
                        data.eatingTimer = 0;
                        if (data.target) {
                            scene.remove(data.target);
                            data.target = null;
                        }
                    }
                    return;
                }

                if (data.state === 'wandering') {
                    bear.position.x += Math.cos(data.direction) * data.speed;
                    bear.position.z += Math.sin(data.direction) * data.speed;

                    if (Math.random() < 0.01) {
                        data.direction += (Math.random() - 0.5) * Math.PI;
                    }

                    if (Math.random() < 0.001) {
                        let closestFlower = null;
                        let closestDistance = Infinity;

                        scene.children.forEach(obj => {
                            if (obj.isFlower) {
                                const distance = bear.position.distanceTo(obj.position);
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestFlower = obj;
                                }
                            }
                        });
                        if (closestFlower) {
                            data.state = 'seeking';
                            data.target = closestFlower;
                        }
                    }
                } else if (data.state === 'seeking') {
                    if (data.target) {
                        const targetPosition = data.target.position;
                        const direction = new THREE.Vector3().subVectors(targetPosition, bear.position).normalize();
                        bear.position.x += direction.x * data.speed;
                        bear.position.z += direction.z * data.speed;

                        if (bear.position.distanceTo(targetPosition) < data.targetDistance) {
                            data.state = 'wandering';
                            data.eating = true;
                        }
                    } else {
                        data.state = 'wandering';
                    }
                }
            });

            birds.forEach(bird => {
                const data = bird.birdData;
                bird.position.x += Math.cos(data.direction) * data.speed;
                bird.position.z += Math.sin(data.direction) * data.speed;
                bird.position.y = data.altitude + Math.sin(Date.now() * data.altitudeChangeSpeed) * data.altitudeVariation;

                if (Math.random() < 0.01) {
                    data.direction += (Math.random() - 0.5) * Math.PI;
                }
            });

            ponds.forEach(pond => {
                const distance = camera.position.distanceTo(pond.position);
                if (distance < 10) {
                    pond.sound.setVolume(1 - distance / 10);
                } else {
                    pond.sound.setVolume(0);
                }

                pond.fishArray.forEach(fish => {
                    fish.position.x += Math.cos(Date.now() * 0.001 + fish.rotation.y) * 0.01;
                    fish.position.z += Math.sin(Date.now() * 0.001 + fish.rotation.y) * 0.01;
                    if (fish.position.x > pond.position.x + 4 || fish.position.x < pond.position.x - 4) fish.rotation.y += Math.PI;
                    if (fish.position.z > pond.position.z + 4 || fish.position.z < pond.position.z - 4) fish.rotation.y += Math.PI;
                });

            });

            humans.forEach(human => {
                const data = human.humanData;
                human.position.x += Math.cos(data.direction) * data.speed;
                human.position.z += Math.sin(data.direction) * data.speed;

                if (Math.random() < 0.01) {
                    data.direction += (Math.random() - 0.5) * Math.PI;
                }
            });

            if (Date.now() - lastSpawnTime > spawnInterval) {
                spawnObjects();
                lastSpawnTime = Date.now();
            }

            if (Date.now() - timeOfDayChange > dayNightCycle) {
                isDay = !isDay;
                timeOfDayChange = Date.now();
                if (isDay) {
                    ambientLight.color.setHex(0x404040);
                    directionalLight.intensity = 0.5;
                } else {
                    ambientLight.color.setHex(0x101010);
                    directionalLight.intensity = 0.2;
                }
            }

            renderer.render(scene, camera);
        }
        // Terrain layers
    const terrainLayers = [];
    const terrainHeight = 10; // Total height of terrain
    const groundSize = 2000;

    function createTerrain() {
        for (let y = 0; y < terrainHeight; y++) {
            const layerGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            let layerMaterial;

            if (y === 0) {
                layerMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); // Green (top layer)
            } else if (y < terrainHeight - 1) {
                layerMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 }); // Stone (middle layers)
            } else {
                layerMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 }); // Black (unbreakable bottom layer)
            }

            const layer = new THREE.Mesh(layerGeometry, layerMaterial);
            layer.rotation.x = -Math.PI / 2;
            layer.position.y = y * -1; // Stack layers downward
            scene.add(layer);
            terrainLayers.push(layer);
        }
    }

    createTerrain();

    // Block breaking
    let isBreaking = false;
    let breakProgress = 0;
    const breakSpeed = 0.05; // Speed of breaking animation
    let targetBlock = null;

    document.addEventListener('mousedown', (event) => {
    if (buildMode && event.button === 0) { // Check buildMode here
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(blocks); // Raycast against blocks
        if (intersects.length > 0) {
            targetBlock = intersects[0].object;
            scene.remove(targetBlock); // Remove from scene
            blocks = blocks.filter(block => block !== targetBlock); // Remove from blocks array
            targetBlock = null;
        }
    }
});

    document.addEventListener('mouseup', () => {
        isBreaking = false;
        breakProgress = 0;
        if (targetBlock) {
            targetBlock.material.opacity = 1; // Reset opacity if breaking is interrupted
            targetBlock.material.transparent = false;
        }
        targetBlock = null;
    });

    function handleBlockBreaking() {
        if (isBreaking && targetBlock) {
            breakProgress += breakSpeed;
            targetBlock.material.transparent = true;
            targetBlock.material.opacity = 1 - breakProgress;

            if (breakProgress >= 1) {
                scene.remove(targetBlock);
                terrainLayers.splice(terrainLayers.indexOf(targetBlock), 1);
                isBreaking = false;
                breakProgress = 0;
                targetBlock = null;
            }
        }
    }

     // Player jumping
     let isJumping = false;
    let jumpVelocity = 0;
    const gravity = 0.01;
    const jumpStrength = 0.2;
    const groundLevel = 0.5; // Define the ground level

    document.addEventListener('keydown', (event) => {
        if (event.key === ' ' && !isJumping) {
            isJumping = true;
            jumpVelocity = jumpStrength;
        }
    });

    function handleJumping() {
        if (isJumping) {
            character.position.y += jumpVelocity;
            jumpVelocity -= gravity;

            if (character.position.y <= groundLevel) { // Ground level check
                character.position.y = groundLevel;
                isJumping = false;
                jumpVelocity = 0; // Reset jump velocity
            }
        }
    }

    
    </script>
</body>

</html>
